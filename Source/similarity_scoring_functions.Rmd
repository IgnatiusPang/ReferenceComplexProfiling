---
title: "R Notebook"
output: html_notebook
---


```{r}
if (!require(pacman)) {
  
  install.packages("pacman")
  library(pacman)
}

p_load(tidyverse)
p_load(Rcpp)
p_load(WGCNA)
p_load(mpmi)
p_load(energy)
p_load(minerva)
p_load(mpmi)


## Install RIC
# a port of Simone Romano's C++ implementation of the Randomized Information Coefficient to R.
# Port written by Lo√Øc Thibalt (loic.thibaut@unsw.edu.au)
# https://github.com/ialuronico/RandomizedInformationCoefficient
p_load(devtools)
install_github("tiboloic/RIC")
p_load(RIC)


```


## Correlation functions
```{r}
#' @name master_correlation_function
#' @param input_pcp_file A file with the  column as the protein name, all other rows are LFQ values for eluted fractions in sequential order 
#' @param type The type of correlation matrics used. 
#' @param number_of_threads The number of CPU threads used to calculate one matrix
#' @value A matrix object representing the correlation scores between every pair of proteins. It should be a symmetrical square matrix. 
master_correlation_function <- function(input_pcp_matrix, type, number_of_threads=1 ) {
  
  input_pcp_matrix <- log10(input_pcp_matrix +1)
  
  if (type %in% c( "Pearson") ) {
    enableWGCNAThreads(nThreads = number_of_threads)
    return ( WGCNA::cor(input_pcp_matrix, method="pearson" , use="all.obs") ) 
  } else if ( type== "Spearman") {
    enableWGCNAThreads(nThreads = number_of_threads)
    return ( WGCNA::cor(input_pcp_matrix, method="spearman" , use="all.obs") ) 
  } else if( type== "Kendall") {
    enableWGCNAThreads(nThreads = number_of_threads)
    return ( WGCNA::cor(input_pcp_matrix, method="kendall" , use="all.obs") ) 
  } else if ( type == "MIC" ) {
    return ( run_mine_on_one_matrix(input_pcp_matrix,  number_of_threads=number_of_threads) ) 
  } else if ( type == "GMIC" ) {
    return ( run_gmic_on_one_matrix(input_pcp_matrix,  number_of_threads=number_of_threads) ) 
  } else if ( type == "TIC" ) {
    return ( run_tic_on_one_matrix(input_pcp_matrix,  number_of_threads=number_of_threads) ) 
  } else if ( type %in% c( "Distance")   ) {
    return ( run_dcor_on_one_matrix_foreach_focused(input_pcp_matrix,  number_of_threads=number_of_threads))
  } else if  ( type %in% c( "BCMI") ) {
    
    # export OMP_NUM_THREADS=8
    Sys.setenv( OMP_NUM_THREADS=number_of_threads)
    # Sys.getenv("OMP_NUM_THREADS")
    return_matrix <- cmi(input_pcp_matrix)$bcmi
    
    colnames(return_matrix ) <- colnames(input_pcp_matrix )
    rownames(return_matrix ) <- colnames(input_pcp_matrix )
    
    return ( return_matrix)
    
  } else if  ( type %in% c("MI")) {
    # export OMP_NUM_THREADS=8
    Sys.setenv( OMP_NUM_THREADS=number_of_threads)
    # Sys.getenv("OMP_NUM_THREADS")
    return_matrix <- cmi(input_pcp_matrix)$mi
    
    colnames(return_matrix ) <- colnames(input_pcp_matrix )
    rownames(return_matrix ) <- colnames(input_pcp_matrix )
    
    return ( return_matrix )
    
  } else if ( type %in% c( "Euclidean")) {
    enableWGCNAThreads(nThreads = number_of_threads)
    
    input_pcp_matrix_norm <- apply ( input_pcp_matrix, 2, function(x) { x/max(x)} ) 
    
    return( adjacency(input_pcp_matrix_norm, distOptions = "method = 'euclidean'") )
  } else if ( type == "RIC" ) {
    return (  run_ric_on_one_matrix_foreach_focused (input_pcp_matrix,  number_of_threads=number_of_threads ) )
  } else if ( type == "DMax") {
    return( run_dmax_on_one_matrix_foreach_focused(input_pcp_matrix,  number_of_threads=number_of_threads) )  
  } else if ( type == "Jaccard") {
  	return( run_jaccard_similarity_on_one_matrix_foreach_focused(input_pcp_matrix,  number_of_threads)  )
  } else if ( type == "Apex") {
  	return( run_apex_score_on_one_matrix_foreach_focused(input_pcp_matrix,  number_of_threads) )
  } else if ( type == "NCC") {
  	return( run_ncc_on_one_matrix_foreach_focused(input_pcp_matrix,  number_of_threads) )
  } else if ( type == "Peak_score") {
  	return( run_peak_score_on_one_matrix_foreach_focused(input_pcp_matrix,  number_of_threads) )
  } else {
  	stop( "master_correlation_function: Type of correlation score not supported.")
  }

}
```

# MIC, TIC, and GMIC
```{r}

## Run MIC correlation 
run_mine_on_one_matrix <- function(input_pcp_matrix,  number_of_threads)  { 
	result_table <- minerva::mine(input_pcp_matrix, n.cores=number_of_threads) 
	
	mic_values <- result_table$MIC
	
	return( mic_values)
	
}


run_tic_on_one_matrix <- function(input_pcp_matrix,  number_of_threads)  { 
	result_table <- minerva::mine(input_pcp_matrix, n.cores=number_of_threads) 
	
	mic_values <- result_table$TIC
	
	return( mic_values)
	
}


run_gmic_on_one_matrix <- function(input_pcp_matrix,  number_of_threads)  { 
	result_table <- minerva::mine(input_pcp_matrix, n.cores=number_of_threads) 
	
	mic_values <- result_table$GMIC
	
	return( mic_values)
	
}


#' @name calculate_minerva
#' @param x a vector of number
#' @param y a vector of number
#' @param method Method should be either MIC, TIC, or GMIC.
#' @number_of_threads Number of threads for parallel calculation
#' @value A numeric value, representing the correlation as calculated by the algorithm specified by input 'method'.
#  calculate_minerva( 1:50, (1:50)^2, method="MIC", number_of_threads=4   )
#  calculate_minerva( rnorm(50), rnorm(50), method="MIC", number_of_threads=4   )
calculate_minerva <- function( x, y, method="MIC", number_of_threads=1 ) {
	
	if( ! method %in% c( "MIC", "GMIC", "TIC")) {
		stop( "calculate_minerva: Type should be either MIC, TIC, or GMIC.")
	}
	
	result_table <- minerva::mine(cbind( x, y ), n.cores=number_of_threads) 
	
	cor_values <- result_table[[method]]
	
	return( cor_values["x", "y"] ) 
} 

```



# BCMI and MI
```{r}

#' @name calculate_mutual_information
#' @description Wrapper for the 'cmi' function from the 'mpmi' library. 
#' @param x a vector of number
#' @param y a vector of number
#' @param method Method should be either MI or BCMI
#' @number_of_threads Number of threads for parallel calculation
#' @value A numeric value, representing the correlation as calculated by the algorithm specified by input 'method'.
#  calculate_mutual_information( 1:50, (1:50)^2, method="MI", number_of_threads=4   )
#  calculate_mutual_information( rnorm(50), rnorm(50), method="MI", number_of_threads=4   )
#  calculate_mutual_information( rnorm(50), rnorm(50), method="BCMI", number_of_threads=4   )
calculate_mutual_information <- function( x, y, method="BCMI", number_of_threads=1 ) {
	
	if( ! method %in% c( "BCMI", "MI")) {
		stop( "calculate_mutual_information: Type should be either BCMI or MI")
	}
	
	Sys.setenv( OMP_NUM_THREADS=number_of_threads)
	
	result_table <- cmi(cbind( x=x, y=y )) 
	
	my_method <- "bcmi"
	
	if( method=="MI") {
		my_method <- "mi"
	} else if ( method=="BCMI") {
		my_method <- "bcmi"
	}
	
	cor_values <- result_table[[my_method]]
	
	return( cor_values[1, 2] )  # 
} 



```

## Distance correlation
```{r}

#############

#' @name run_dcor_on_one_matrix_foreach_focused_parallel_part
#' @description Run distance correlation on the input PCP matrix. 
#' @param input_pcp_matrix: Uses the output from the 'read_input_pcp_file' function. It is a matrix with column names representing proteins and row names representing the PCP fraction number.
#' @param number_of_threads: Number of CPUs dedicated to the analysis
#' @value A numeric matrix

run_dcor_on_one_matrix_foreach_focused <- function(input_pcp_matrix,  number_of_threads)  { 
  
  # list_of_pairs <- run_dcor_on_one_matrix_foreach_focused_parallel_part(input_pcp_matrix,  number_of_threads )
  
  # list_of_pairs <- dplyr::bind_cols(list_of_pairs,  data.frame( dcor=results) ) %>% as.data.frame()
  tic()
  list_of_pairs <- run_corr_on_one_matrix_foreach_focused_parallel_part(input_pcp_matrix,  number_of_threads, 
  																	  .export=c(), .packages=c("energy", 'tidyverse'),  FUNC=dcor,
  																	  protein_a_column="protein_a", protein_b_column="protein_b", 
  																	  score_column="dcor")	
  toc()
  
  tic()
  dcor_return_matrix <- run_cor_on_one_matrix_foreach_focused_edge_list_to_matrix( list_of_pairs, "protein_a", "protein_b", "dcor", diagonal_score=1)
  toc()
  
  return( dcor_return_matrix)
  
}
```



# RIC
```{r}
#' @param input_pcp_matrix: Uses the output from the 'read_input_pcp_file' function. It is a matrix with column names representing proteins and row names representing the PCP fraction number.
#' @param number_of_threads: Number of CPUs dedicated to the analysis
#' @value A numeric matrix
run_ric_on_one_matrix_foreach_focused <- function(input_pcp_matrix,  number_of_threads, Kr=200, Dmax=NULL)  { 
  
  if( is.null(Dmax) ) {
		num_records <- length(input_pcp_matrix[,1])
		Dmax <- floor(sqrt(num_records)) - 1;
  }
	
  tic()
  list_of_pairs <- run_corr_on_one_matrix_foreach_focused_parallel_part(input_pcp_matrix,  number_of_threads, .export=c(),
																			.packages=c('Rcpp', "RIC", 'tidyverse'),
																			FUNC=RIC,
																			protein_a_column="protein_a", protein_b_column="protein_b", 
																			score_column="RIC", 
																			Kr=Kr, Dmax=Dmax)
  toc()
  
  tic()
  ric_return_matrix <- run_cor_on_one_matrix_foreach_focused_edge_list_to_matrix( list_of_pairs, "protein_a", "protein_b", "RIC", 
  																				  diagonal_score=1)
  toc()
  
  return( ric_return_matrix)
  
}
```

# Euclidean distance 
```{r}
#' @description Calculates the euclidean distance. Normalize x and y vector first. 
euclidean_distance <- function(x, y) { 

  
	if( length(x) != length(y)) {
		stop("euclidean_distance: length of x is not equal to length of y. Abort.")
	}
  
  x_norm <- x/max(x)
  y_norm <- y/max(y)
	
	return( sqrt(sum((x_norm - y_norm) ^ 2)))
	
} 

```



# DMax
```{r}
## Example: Dmax(rlnorm(100), rlnorm(100))
## Output value should be greater than 1
## Dmax function Contributed by Loic Thibaut (loic.thibaut@unsw.edu.au)
Dmax = function(x,y) {
  
  if( length(x) != length(y)) {
    stop("Dmax: length of x is not equal to length of y. Abort.")
  }
  
  c.x = cumsum(x)
  c.y = cumsum(y)
  max(abs(c.x/max(c.x)-c.y/max(c.y)))
  
  
}

Dmax_positive <- function( x, y ) {

  if( length(which(x < 0 ))> 0 | 
      length(which(y < 0 ))  > 0 ) {
    
    stop ( "Dmax_positive: input vectors must be all zero or positive values.")  
  } else {
    
    return ( Dmax( x, y))
  }
  
}

#' @param input_pcp_matrix: Uses the output from the 'read_input_pcp_file' function. It is a matrix with column names representing proteins and row names representing the PCP fraction number.
#' @param number_of_threads: Number of CPUs dedicated to the analysis
#' @value A numeric matrix
run_dmax_on_one_matrix_foreach_focused <- function(input_pcp_matrix,  number_of_threads)  { 
  
  tic()
  list_of_pairs<- run_corr_on_one_matrix_foreach_focused_parallel_part(input_pcp_matrix,  number_of_threads, 
  																	 .export=c('Dmax_positive', "Dmax"),
  														.packages=c( 'tidyverse'),
  														FUNC=Dmax_positive,
  														protein_a_column="protein_a", protein_b_column="protein_b", 
  														score_column="DMax")
  toc()
  
  tic()
  dmax_return_matrix <- run_cor_on_one_matrix_foreach_focused_edge_list_to_matrix( list_of_pairs, "protein_a", "protein_b", "DMax", diagonal_score=1)
  toc()
  
  return( dmax_return_matrix)
  
}
```

## NCC
```{r}

# By Lo√Øc Thibalt (loic.thibaut@unsw.edu.au) 09/12/2018
#' @name LT.crosscor
#' @description Calculate the numeric cross-correlation. Calculate the similarity in two vectors if one series is shifted across in relation to the other.
#' @param x A numeric vector 
#' @param y A numeric vector of the same length as x
#' @references https://docs.scipy.org/doc/numpy-1.14.0/reference/generated/numpy.correlate.html
#' @value A numeric value
LT.crosscor = function(x, y) {
  
  # arguments type & size should be checked
  n = length(x)
  
  # dummy square matrix to build shift matrix  
  A = matrix(0, n, n)
  
  # shift matrix
  shift = pmax(row(A)-col(A) + 1, 0) + 1
  
  # shift x and y
  shiftedX = matrix(c(0,x)[shift], n)
  shiftedY = matrix(c(0,y)[shift], n)
  
  max(y %*% shiftedX, x %*% shiftedY)
  
}

# By Lo√Øc Thibalt (loic.thibaut@unsw.edu.au) 09/12/2018
#' @name LT.NCC
#' @description The normalized cross-correlation NCC was derived in 2 steps. First, we computed the maximum cross correlation between the two peak pairs P 1‚Äì2 CC. We then computed the maximum self-cross-correlation of the first peak (P 1 CC) and the max self-cross-correlation of the second peak (P 2 CC). The NCC was finally derived as P 1‚Äì2 CC/max(P 1 CC, P 2 CC). The NCC assume values between 0 and 1.
#' @references: Larance M, et al. (2016) Global Membrane Protein Interactome Analysis using In vivo Crosslinking and Mass Spectrometry-based Protein Correlation Profiling. Mol Cell Proteomics. 15(7):2476-90., https://github.com/mtinti/score_signal/blob/master/scoring_matrix.py, https://docs.scipy.org/doc/numpy-1.14.0/reference/generated/numpy.correlate.html
#' @param x A numeric vector 
#' @param y A numeric vector of the same length as x
#' @value A numeric value between 0 and 1, 1 means the two input vectors are similar, 0 means the two input vectors are not similar. 
LT.NCC = function(x,y) {
  LT.crosscor(x,y)/max(crossprod(x), crossprod(y))
}


run_ncc_on_one_matrix_foreach_focused <- function(input_pcp_matrix,  number_of_threads)  { 
	
	tic()
	list_of_pairs<- run_corr_on_one_matrix_foreach_focused_parallel_part(input_pcp_matrix,  number_of_threads, 
																		 .export=c('LT.crosscor', "LT.NCC"),
																		 .packages=c('tidyverse'),
																		 FUNC=LT.NCC,
																		 protein_a_column="protein_a", protein_b_column="protein_b", 
																		 score_column="NCC")
	toc()
	
	tic()
	ncc_return_matrix <- run_cor_on_one_matrix_foreach_focused_edge_list_to_matrix( list_of_pairs, "protein_a", "protein_b", "NCC", diagonal_score=1)
	toc()
	
	return( ncc_return_matrix)
	
}

```

# Jaccard similarity
```{r}

#' @name jaccard_similarity
#' @Descriptions Calculate the Jaccard similarity index. This is the number of fractions in which protein A and protein B are present divided by the number of fractions in which either protein A or B are present. (e.g. Jaccard similarity = | A intersect B | / | A union B |  )
#' @param x A numeric vector 
#' @param y A numeric vector of the same length as x
#' @Wikipedia https://en.wikipedia.org/wiki/Jaccard_index
jaccard_similarity <- function( x, y ) {
	
	if( length(x) != length(y) ) {
		stop( paste0(as.list(sys.call())[[1]], ": length of x and y must be the same"))
	}
	
	if( length (x) == 0 ) {
		stop( paste0(as.list(sys.call())[[1]], ": length of x and y must be greater than zero"))
	}
	
	# If Both X and Y are empty, then return 1
	if( length(which(x != 0)) == 0 & length(which(y != 0)) == 0 ) {
		
		return( 1)
	}

	## Change to zerio if the data is NA
	cleaned_data <- purrr::map( list(x=x, y=y),  ~ifelse(  is.na(.) , 0, .) )
	
	## In boty X and Y 
	x_intersect_y <- length( which ( cleaned_data$x != 0 & cleaned_data$y != 0  )) 
	
	x_union_y <- length( which(  cleaned_data$x != 0 | cleaned_data$y != 0  ))
	
	jaccard_score <-  x_intersect_y / x_union_y 
		
	return( jaccard_score )
	
}


run_jaccard_similarity_on_one_matrix_foreach_focused <- function(input_pcp_matrix,  number_of_threads)  { 
	
	tic()
	list_of_pairs<- run_corr_on_one_matrix_foreach_focused_parallel_part(input_pcp_matrix,  number_of_threads, 
																		 .export=c('jaccard_similarity'),
																		 .packages=c('tidyverse'),
																		 FUNC=jaccard_similarity,
																		 protein_a_column="protein_a", protein_b_column="protein_b", 
																		 score_column="Jaccard")
	toc()
	
	tic()
	jaccard_return_matrix <- run_cor_on_one_matrix_foreach_focused_edge_list_to_matrix( list_of_pairs, "protein_a", "protein_b", "Jaccard", diagonal_score=1)
	toc()
	
	return( jaccard_return_matrix)
	
}
```

# Apex score
```{r}

#' @name apex_score
#' @description If the maximum value of both vectors are in the same vector position (or PCP fraction), then return one, otherwise zero. 
#' @param x A numeric vector 
#' @param y A numeric vector of the same length as x
#' @return Returns 0 or 1. 
#' @references Havugimana PC et al (2012) A census of human soluble protein complexes. Cell 150(5):1068‚Äì1081. 
apex_score <- function( x, y ) {
	
	if( length(x) != length(y) ) {
		stop( paste0(as.list(sys.call())[[1]], ": length of x and y must be the same"))
	}
	
	if( length (x) == 0 |  length (y) == 0 ) {
		stop( paste0(as.list(sys.call())[[1]], ": length of x and y must be greater than zero"))
	}
	
	cleaned_data <- purrr::map( list(x=x, y=y),  ~ifelse(  is.na(.) | is.nan(.) , 0, .) )
	
	position_max_x <- which( cleaned_data$x == max(cleaned_data$x))
	position_max_y <- which(cleaned_data$y == max(cleaned_data$y))
	common_peak_position <- intersect(position_max_x, position_max_y ) 
	
	if( length(common_peak_position) >=1 ) {
		return(1)
	} else {
		return( 0 )
	}

}


run_apex_score_on_one_matrix_foreach_focused <- function(input_pcp_matrix,  number_of_threads)  { 
	
	tic()
	list_of_pairs<- run_corr_on_one_matrix_foreach_focused_parallel_part(input_pcp_matrix,  number_of_threads, 
																		 .export=c('apex_score'),
																		 .packages=c('tidyverse'),
																		 FUNC=jaccard_similarity,
																		 protein_a_column="protein_a", protein_b_column="protein_b", 
																		 score_column="Apex")
	toc()
	
	tic()
	apex_return_matrix <- run_cor_on_one_matrix_foreach_focused_edge_list_to_matrix( list_of_pairs, "protein_a", "protein_b", "Apex", diagonal_score=1)
	toc()
	
	return( apex_return_matrix)
}
```

# Peak Score
```{r}
#' @name peak_score
#' @description Find the distance in the number of fraction between the location of the highest peak for two vectors. 
peak_score <- function( x, y )  {
	
	if( length(x) != length(y) ) {
		stop( paste0(as.list(sys.call())[[1]], ": length of x and y must be the same"))
	}
	
	if( length (x) == 0 |  length (y) == 0 ) {
		stop( paste0(as.list(sys.call())[[1]], ": length of x and y must be greater than zero"))
	}
	
	max_x_position <- which( x == max(x))[1]
	max_y_position <- which( y== max(y))[1]
	
	return( abs( max_x_position - max_y_position))
	
}


run_peak_score_on_one_matrix_foreach_focused <- function(input_pcp_matrix,  number_of_threads)  { 
	
	# list_of_pairs <- run_dcor_on_one_matrix_foreach_focused_parallel_part(input_pcp_matrix,  number_of_threads )
	
	# list_of_pairs <- dplyr::bind_cols(list_of_pairs,  data.frame( dcor=results) ) %>% as.data.frame()
	tic()
	list_of_pairs <- run_corr_on_one_matrix_foreach_focused_parallel_part(input_pcp_matrix,  number_of_threads, 
																		  .export=c(), .packages=c(),  FUNC=peak_score,
																		  protein_a_column="protein_a", protein_b_column="protein_b", 
																		  score_column="Peak_score")	
	toc()
	
	tic()
	dcor_return_matrix <- run_cor_on_one_matrix_foreach_focused_edge_list_to_matrix( list_of_pairs, "protein_a", "protein_b", "Peak_score", diagonal_score=0)
	toc()
	
	return( dcor_return_matrix)
	
}

```


# Co-apex scores
```{r}

#' @name calculate_co_apex_score_one_dataset
#' @Description Calculate co-apex score for an input peaks table, output from the Prince software. Euclidean distance between the closest (Œº, œÉ) pairs, where Œº and œÉ are Gaussian parameters fitted to ci and c j . For example, if c i is fit by two Gaussians with (Œº, œÉ) equal to (5, 1) and (45, 3), and c j is fit by one Gaussian with parameters (45, 2). Calculate the euclidean distance between c i and c j. Thus chromatograms with at least one pair of similar Gaussian peaks will have a low (similar) Co-apex score.
#' @param input_table The output from the Prince peak picking tool but with an additional expt_name column (see the parameter 'expt_name_col').
#' @param protein_name_col  a string indicating the column name
#' @param exp_name_col a string indicating the experiment tag column. It is to enable comparing the table with itself to define protein pairs.
#' @return an edge list with the followig columns: column_a, column_b, and the Co-apex score
#' @reference Scott NE et al. (2015) Development of a computational framework for the analysis of protein correlation profiling and spatial proteomics experiments. J Proteomics. 118:112-29.

calculate_co_apex_score_one_dataset <- function( input_table, protein_name_col, expt_name_col  ) {
	
	column_a <- as.name( paste0( protein_name_col, ".x" ) )
	column_b <- as.name( paste0( protein_name_col, ".y") ) 
	
	##  I wanted to be able to use enquo and UQ for the expt_name_col too, but don't have an idea yet, so currently stick with string.
	column_a_quoted <- enquo(column_a)
	column_b_quoted <- enquo(column_b)
	
	input_table_filtered <- input_table
	
	
		compare_peaks_table <- input_table_filtered %>%
		                       dplyr::inner_join( input_table_filtered, by= expt_name_col )  %>%
							   dplyr::filter( !!column_a_quoted > !!column_b_quoted ) 
		
		compare_peaks_table_dist <-  compare_peaks_table %>%
									 dplyr::mutate( co_apex = sqrt( (Center.x - Center.y)^2 + ( abs(Width.x) - abs(Width.y))^2/2 ) ) 
		
		
		compare_peaks_table_dist_min <- compare_peaks_table_dist %>%
									    dplyr::select( UQ(column_a_quoted), UQ(column_b_quoted),  co_apex )%>%
									    dplyr::group_by ( UQ(column_a_quoted), UQ(column_b_quoted)) %>%
									    dplyr::summarise( co_apex= min(co_apex)  ) %>%
									    dplyr::ungroup()
		
		#print(head ( compare_peaks_table_dist_min))
		
		compare_peaks_table_dist_min_joined <- compare_peaks_table_dist %>%
		 	dplyr::inner_join( compare_peaks_table_dist_min, 
		 					   by=c( as.character( column_a),  as.character(column_b), "co_apex"))  %>%
		 	dplyr::select( UQ(column_a_quoted), peak_number.x, UQ(column_b_quoted),  peak_number.y,  co_apex   ) %>%
		 	dplyr::group_by(UQ(column_a_quoted), UQ(column_b_quoted ) ) %>%
		 	dplyr::mutate( pair_distance_id = row_number() )  %>%
		 	## Remove entries with distance > 0, in case some proteins have different 
		 	## Uniprot_acc but are duplicated proteins and therefore has same PCP profiles
            dplyr::filter( ! ( co_apex == 0 &  pair_distance_id > 1) ) %>%
		 	dplyr::select( - pair_distance_id) %>%
		 	dplyr::ungroup() %>%
		 	dplyr::distinct()
		 
		 #print(head( compare_peaks_table_dist_min_joined))
		
		return( compare_peaks_table_dist_min_joined)
}




#' @name  run_cor_on_one_matrix_foreach_focused_edge_list_to_matrix
#' @description Given a table with a protein A column, protein B column and a score column (long format), convert into a square matrix. The diagonal values are filled in using user specified value(s) (see diagonal_score parameter).
#' @param list_of_pairs: A table containing the following columns Protein A accession (protein_a), Protein B accession (protein_b), and the correlation score column. Takes the output from the function 'calculate_co_apex_score_one_dataset'
#' @param protein_a_column Name of protein A column 
#' @param protein_b_column Name of protein B column 
#' @param score_column Name of score column
#' @param diagonal_score: Score to fill in for the diagonal part of the square matrix. 
run_cor_on_one_matrix_foreach_focused_edge_list_to_matrix <- function(list_of_pairs, protein_a_column, protein_b_column, score_column, diagonal_score=1) {
	
	## Top half of interactions matrix
	selected_columns <- list_of_pairs %>%
		dplyr::select( one_of( c( protein_a_column, protein_b_column, score_column)))
	
	if ( ncol( selected_columns) != 3) {
		stop( "run_cor_on_one_matrix_foreach_focused_edge_list_to_matrix: Something wrong with the column names.")
	}
	
	## Bottom half of interactions matrix 
	list_of_pairs_part_2 <- list_of_pairs %>%
		dplyr::select( one_of( c( protein_a_column, protein_b_column, score_column))) %>%
		dplyr::rename_( .dots= setNames( as.list( protein_b_column ), c("temp"))) %>% 
		dplyr::rename_( .dots= setNames( as.list( protein_a_column ), c(protein_b_column))) %>% 
		dplyr::rename_( .dots= setNames( as.list( "temp" ), c(protein_a_column))) 
	
	## The diagonal of the matrix, which is all equal to the 'diagonal_score'
	list_of_all_proteins <- as.vector( unique(c( as.vector(unlist(list_of_pairs[,1])), as.vector(unlist(list_of_pairs[,2])))))
	
	# print(list_of_all_proteins )
	# print( paste( "length of list_of_all_proteins =",  length( list_of_all_proteins)) )
	
	if( length( diagonal_score) == 1) {
		
		list_of_pairs_part_3 <- data.frame( list_of_all_proteins, 
											list_of_all_proteins, 
											rep(diagonal_score, length(list_of_all_proteins))   )
	} else if (  length( diagonal_score) == length(list_of_all_proteins)) {
		
		list_of_pairs_part_3 <- data.frame( list_of_all_proteins, 
											list_of_all_proteins, 
											diagonal_score   )
	} else {
		
		stop("run_cor_on_one_matrix_foreach_focused_edge_list_to_matrix: The input to diagonal_score should be of length 1 or the length of the number of proteins present in the input matrix.")
	}
	
	colnames( list_of_pairs_part_3  ) <- c(protein_a_column, protein_b_column, score_column )
	
	## Combine top, bottom and diagonal 
	list_of_pairs <- dplyr::bind_rows( list_of_pairs, list_of_pairs_part_2, list_of_pairs_part_3)
	
	results_matrix <- list_of_pairs %>%
						tidyr::spread( protein_b_column, score_column)
	
	new_row_names_to_use <- unlist( results_matrix[, protein_a_column] ) 
	
	results_matrix <- as.data.frame( results_matrix[, 2:ncol(results_matrix)] )
	
	rownames( results_matrix) <-  new_row_names_to_use
	
	results_matrix <- as.matrix(results_matrix)
	
	return( results_matrix)
	
}



calculate_co_apex_score <-  function(input_table) {
	
  co_apex_scores <- calculate_co_apex_score_one_dataset( input_table, "Protein name", "expt_name") 
  
	co_apex_scores_cleaned <- co_apex_scores %>% 
							  dplyr::select( -peak_number.x, -peak_number.y ) %>%
							  dplyr::rename( uniprot_acc_a = "Protein name.x", uniprot_acc_b = "Protein name.y") %>%
							  dplyr::distinct()
	
	co_apex_scores_matrix <- run_cor_on_one_matrix_foreach_focused_edge_list_to_matrix(co_apex_scores_cleaned, 
																								    "uniprot_acc_a", "uniprot_acc_b", 
																								    "co_apex", diagonal_score=0) 
	
	return(co_apex_scores_matrix)
}


```



# Function to calculate the correlation / scoring matrix between all pairs of proteins, given an input PCP table 
```{r}
#' @name format_input_pcp_matrix
#' @description Convert the input matrix into a data.frame object for use in 'master_correlation_function'
#' @param input_data_frame A data frame with the first column as file name, all other columns are LFQ values for eluted fractions ordered from first (left) to last (right) fractions. 
#' @return A numeric matrix object with proteins as columns and fractions as names. 
format_input_pcp_matrix <- function(input_data_frame) {
  
  input_row_names <- input_data_frame[,1]
  input_col_names <- colnames( input_data_frame)[2:ncol(input_data_frame)]
  
  input_data_frame <- input_data_frame[,2:ncol(input_data_frame)] %>% as.matrix
  
  rownames(input_data_frame) <- input_row_names
  colnames(input_data_frame ) <- input_col_names
  
  ## Remember to transpose the matrix so that we are comparing the proteins 
  input_data_frame <- t( input_data_frame)
  
  return (input_data_frame )
}



#' @name read_input_pcp_file
#' @description Convert the input file into a data.frame object for use in 'master_correlation_function'
#' @param input_pcp_file A file with the first column as file name, all other columns are LFQ values for eluted fractions ordered from first (left) to last (right) fractions. 
#' @return A numeric matrix object with proteins as columns and fractions as names. 
read_input_pcp_file <- function( input_pcp_file ){
  
  input_data_frame <- read.table( input_pcp_file, sep="\t", header=TRUE)

  input_matrix <- format_input_pcp_matrix(input_data_frame) 
  
  return (input_matrix )
  
}

# Function: read_input_pcp_file
# Description: Given text file and choice of correlation metric, save the correlation matrix as an R object.
#'@param correlation_metric  Type of correlation metric, available choices are Pearson, Spearman, Kendall, MIC, Distance
#'@param elution_profile_file A file with the first column as file name, all other columns are LFQ values for eluted fractions ordered from first (left) to last (right) fractions. 
#'@param correlation_scores_file Full path of the output file
#'@param number_of_threads Number of threads that are available for the function to use. 
calculate_correlation_and_save_table <- function( correlation_metric, elution_profile_file, correlation_scores_file, number_of_threads, random_number_seed = 1985)  {
  
  if (!file.exists( correlation_scores_file) ) {

    set.seed(random_number_seed, "L'Ecuyer-CMRG")
    
    print( "Do calculations")
    input_matrix <- read_input_pcp_file( elution_profile_file )
    
    print ( head( input_matrix[1:10, 1:10]) ) 
    
    correlation_matrix <- master_correlation_function( input_matrix, type=correlation_metric, number_of_threads=number_of_threads )
    
    create_directory_if_not_exists( dirname(correlation_scores_file))
  
    saveRDS( correlation_matrix, file= correlation_scores_file )
  }
  
}

```



